---
sidebar_position: 4
tags: [OWASP, XSS]
title: XSS
sidebar_label: XSS
description: 介绍 XSS 注入漏洞&ByPass&利用
slug: /penetration/OWASP/4
---
# XSS
## 介绍
XSS 的漏洞本质原因是客户端将服务器返回的数据, 作为了 **JS** 进行执行, 而不是作为数据渲染.

## Exploit
对于 XSS 而言, 一般会采取下面的几种方式来扩展攻击:
* 盗取用户身份信息, 窃取会话 Cookie 从而窃取网站用户隐私、账号、浏览历史等等
* 伪授权操作, 通过 JS 发起敏感请求
* 按键记录和钓鱼
* 蠕虫病毒传播, 借助网站进行传播, 使网站的使用用户受到攻击
* 劫持用户会话, 从而知悉任意操作, 比如: 弹窗跳转、篡改页面、网页挂马

:::tip[XSS 的分类]
- 反射型 XSS
- 存储型 XSS
- Dom 型 XSS
:::
### 反射型 XSS
:::info
特点 : pyaload 不会存储在数据库, 一般出现在查询页面（输入内容会直接返回的参数都可能存在反射型XSS）

**反射型XSS，又称非持久型XSS，攻击相对于受害者而言是一次性的**
:::

攻击者诱导受害者点击包含恶意JavaSctipt代码的URL，当受害者点击这些精心设计的链接后，恶意代码会直接在受害者主机上的浏览器执行；恶意代码并没有保存在目标网站，而Web应用程序只是不加处理的把该恶意脚本“反射”回受害者的浏览器而使受害者的浏览器执行相应的脚本

![20240411195911](https://raw.githubusercontent.com/Guardian-JTZ/Image/main/img/20240411195911.png)

1. 攻击者将payload放置在url链接中（这是针对是GET型反射XSS）
2. 用户点击该恶意链接
3. web服务将XSS代码（JavaScript代码）以及视图返回给客户端
4. 客户端解析视图以及XSS代码（JavaScript代码），并将执行结果发送到XSS平台
5. 攻击者访问XSS平台，读取用户的敏感信息（Cookie)

### 存储型 XSS
:::info
特点 : payload会存在数据库里面，一般出现在会将数据存储到数据库中并展示在前端页面的功能，如注册页、留言板等
:::

存储型 XSS 是指将应用程序将存在 XSS Payload 的数据**未进行过滤检查便存入到数据库**中, 当下一次从数据库中**获取数据时也没有进行过滤**, 直接将其显示在前端, 导致了 XSS Payload 的执行

![20240411200104](https://raw.githubusercontent.com/Guardian-JTZ/Image/main/img/20240411200104.png)

1. 攻击者向web服务插入XSS代码
2. web服务会将其结果存储到数据库中
3. 用户正常访问web服务
4. web服务将数据库的数据以及视图返回给前端，前端渲染视图并加载数据，其中数据里包含恶意XSS代码（JavaScript代码）
5. 客户端渲染视图，加载XSS代码，并向攻击者的web服务发送敏感信息
6. 攻击者读取用户的敏感信息

### DOM 型 XSS
:::info
不会与服务器交互也不会存储在数据库中, 通过 Dom 操作前端输出的时候产生问题 (相比于前两种较难挖掘, 需要熟悉基础 JS 代码)
:::
客户端的脚本程序可以动态的检查和修改页面内容, 而不依赖于服务端的数据, 比如 客户端如果从**URL 中提取数据并在本地执行**, 如果用户在客户端的输入数据包含了恶意的 JS 内容, 而这些内容没有经过过滤, 那么应用程序就可能受到 Dom 型 XSS 攻击

![20240411200646](https://raw.githubusercontent.com/Guardian-JTZ/Image/main/img/20240411200646.png)

1. 攻击者将payload放置在url链接中（这是针对是GET型反射XSS）
2. 用户点击恶意链接，并打开浏览器
3. 此时浏览器客户端并不会发起http请求到web服务，而是在浏览器客户端执行XSS（JavaScript代码）
4. 此时将XSS代码执行结果发送给攻击者的恶意服务
5. 攻击者访问自己的XSS平台并读取用户的敏感信息

## 防御
* 输入检查 : 老办法了, 黑白名单、数据类型、数据内容
* 输出编码 : URL 编码、HTML 编码、JS 编码
* httponly 策略 : 禁止 JS 读取敏感 Cookie (这并不能防御 XSS 漏洞, 只是解决利用 XSS 进行 Cookie 劫持的问题)
* CSP 策略: 个人认为比较完美的解决方式
  * 禁止加载外域代码，防止复杂的攻击逻辑。
  * 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。
  * 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。
  * 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。
  * 合理使用上报可以及时发现 XSS，利于尽快修复问题。

## XSS 挖掘
### 黑盒测试
对所有的可控参数进行逐个尝试, 常见的区域有: 名称、图片等地址

> 我一般挖 XSS 漏洞都是黑盒挖掘, 看到所有的参数位置都进行一遍尝试

### 白盒测试
- 观察后端代码的过滤是否存在缺陷可以绕过

> 一般很少白盒寻找 XSS 代码, 都有代码了不找命令执行这种, 找什么 XSS

### 常见挖掘手段
- 在 HTML 中内嵌的文本那种，恶意内容以 script 标签形成注入
- 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串、变量、方法名等）
- 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签
- 在标签的 href、src 等属性中，包含 javascript: 等可执行代码
- 在 onload、onerror、onclick 等事件中，注入不受控制代码
- 在 style 属性和标签汇总，包含类似 background-image: url("javascript:...") 的代码（新版本浏览器已经可以防范）
- 在 style 属性和标签中，包含类似 expression(...) 的 CSS 表达式代码（新版本浏览器已经可以防范）

## ByPass
1. 使用遍历手段, 看看过滤了哪些字符或者事件函数
2. 对于过滤的字符可以尝试编码或者半闭合的手段进行绕过, 对于事件函数可以尝试换其他标签进行操作
3. 之后根据具体情况尝试 双写、编码、拼接等等操作
4. 去找一些 XSS Payload 集合

## Questions
### XSS 之间的差别

|| **反射型** | **存储型**| **DOM型**|
|--|--|--|--|
| 攻击对象 | 需要攻击者主动寻找受害者并诱导其访问 | 广撒网，只要有用户访问对应的页面就会触发，危害性更大，范围更广   | 需要攻击者主动寻找受害者并诱导其访问（同反射型） |
| 持久性   | 一次性                               | 只要服务器不宕机，payload不被手动删除，就一直存在                | 一次性                                           |
| 触发点   | 网站中直接返回参数内容的功能点       | 网站中将数据直接存储到数据库中，后直接返回数据在前端展示的功能点 | 取决于DOM节点                                    |

### XSS 和 CSRF 的区别
| 类别 | **特征** |
|--|--|
| XSS  | 1. 主要是加载JavaScript代码，在客户端执行<br />2. 虽然经过后端，数据库（存储型），但主要需要客户端执行XSS代码，才能生效<br />3. DOM型XSS一定不经过后端，只是对浏览器客户端发起的攻击<br />4. XSS攻击针对的是用户层面的攻击 （攻击客户端）<br /> |
| CSRF | 1. 主要是欺骗服务器，虽然是由用户发起，但是服务器无法判断是否是不是用户想要发起的请求<br />2. 一定会经过后端处理，不然无法执行<br />3. CSRF是一种身份伪造攻击，来对服务器进行欺骗的一种攻击手法/<br />                                      |
